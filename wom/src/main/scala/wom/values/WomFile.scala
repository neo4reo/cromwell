package wom.values

import wom.types._

import scala.util.{Success, Try}

sealed trait WomFile extends WomPrimitive {

  // TODO: WOM: WOMFILE: This is often used as _either_ the cloud location _or_ the path within the container. Does this need to be split into two values?
  val value: String

  override def valueString = value

  // TODO: WOM: WOMFILE: When WDL supports directories this check may need more work (refactoring to subclasses?)
  override def equals(rhs: WomValue): Try[WomBoolean] = rhs match {
    case r: WomFile => Success(WomBoolean(value.equals(r.value) && womType.equals(r.womType)))
    case r: WomString => Success(WomBoolean(value.toString.equals(r.value.toString)))
    case r: WomOptionalValue => evaluateIfDefined("==", r, equals)
    case _ => invalid(s"$value == $rhs")
  }

  /**
    * Converts the location using f() recursively converting any files referred to by this file.
    *
    * @param f The function to update the location.
    * @return A new WomFile with the updated location.
    */
  def mapFile(f: String => String): WomFile

  /**
    * Returns the WomFile recursively referenced by this instance.
    *
    * WomSingleDirectory return either just the directory, or if there is Some listing then just the recursive listing
    * entries. WomSingleFile return that instance plus any instances recursively discovered in secondaryFiles.
    * WomGlobFile return just the instance.
    */
  def flattenFiles: Seq[WomFile] = {
    this match {
      case womSingleDirectory: WomSingleDirectory =>
        womSingleDirectory.listingOption.getOrElse(Nil).toList match {
          case Nil => List(this)
          case list => list.flatMap(_.flattenFiles)
        }
      case womSingleFile: WomSingleFile =>
        womSingleFile.secondaryFiles.foldLeft(List(this)) {
          (womFiles, womSingleDirectoryOrFile) =>
            womFiles ++ womSingleDirectoryOrFile.flattenFiles
        }
      case womGlobFile: WomGlobFile => List(womGlobFile)
    }
  }
}

object WomFile {
  def apply(fileType: WomFileType, value: String) = {
    fileType match {
      case WomSingleDirectoryType => WomSingleDirectory(value)
      case WomSingleFileType => WomSingleFile(value)
      case WomGlobFileType => WomGlobFile(value)
    }
  }
}

sealed trait WomSingleDirectoryOrFile extends WomFile {
  // TODO: WOM: WOMFILE: When WDL supports the other parts beyond `value`, toWomString should return the _WDL_ string.
  override def toWomString = s""""$value""""

  override def mapFile(f: String => String): WomSingleDirectoryOrFile
}

/**
  * A directory with an optional listing of other files/directories.
  *
  * A user may supply a directory listing where the files/directories are not technically sub-directories of this
  * parent.
  *
  * Directories with listings set to None should not be passed into command line generation. Instead, the execution
  * engine should create a copy of this instance by locating the files/directories within the `value` and filling in the
  * listing with Some Seq.
  *
  * @param value         The location of the directory, possibly in the cloud.
  * @param listingOption An optional listing of files/directories, either supplied by a user or generated by the engine.
  */
case class WomSingleDirectory(value: String,
                              listingOption: Option[Seq[WomSingleDirectoryOrFile]] = None
                             ) extends WomSingleDirectoryOrFile {
  override val womType: WomType = WomSingleDirectoryType

  override def add(rhs: WomValue): Try[WomValue] = rhs match {
    case r: WomString => Success(WomSingleDirectory(value + r.value))
    case r: WomOptionalValue => evaluateIfDefined("+", r, add)
    case _ => invalid(s"$value + $rhs")
  }

  override def mapFile(f: String => String): WomSingleDirectory = {
    this.copy(value = f(value), listingOption.map(_.map(_.mapFile(f))))
  }
}

/**
  * A file with optional sub files/directories. The contents may have been provided by the user and will need to be
  * written by the engine before executing the command.
  *
  * @param value          The location of the file, possibly in the cloud.
  * @param checksumOption An optional checksum of the file contents.
  * @param sizeOption     An optional size of the file contents in bytes.
  * @param formatOption   An optional format description of the file contents.
  * @param contentsOption The optional text contents of the file.
  * @param secondaryFiles Any files associated with this file.
  */
case class WomSingleFile(value: String,
                         checksumOption: Option[String] = None,
                         sizeOption: Option[Long] = None,
                         formatOption: Option[String] = None,
                         contentsOption: Option[String] = None,
                         secondaryFiles: Seq[WomSingleDirectoryOrFile] = Vector.empty
                        ) extends WomSingleDirectoryOrFile {

  override val womType: WomType = WomSingleFileType

  override def add(rhs: WomValue): Try[WomValue] = rhs match {
    case r: WomString => Success(WomSingleFile(value + r.value))
    case r: WomOptionalValue => evaluateIfDefined("+", r, add)
    case _ => invalid(s"$value + $rhs")
  }

  override def mapFile(f: String => String): WomSingleFile = {
    this.copy(value = f(value), secondaryFiles = secondaryFiles.map(_.mapFile(f)))
  }
}

/**
  * A glob that will be expanded into an array of files from the path in value.
  *
  * Ex:
  * {{{
  *   Array[File] myBams = glob("outdir/\*.bam")
  * }}}
  *
  * @param value The path of the glob within the container.
  */
case class WomGlobFile(value: String) extends WomFile {
  override val womType: WomType = WomGlobFileType

  override def toWomString = s"""glob("$value")"""

  override def add(rhs: WomValue): Try[WomValue] = rhs match {
    case r: WomString => Success(WomGlobFile(value + r.value))
    case r: WomOptionalValue => evaluateIfDefined("+", r, add)
    case _ => invalid(s"$value + $rhs")
  }

  override def mapFile(f: String => String): WomGlobFile = this.copy(value = f(value))
}
